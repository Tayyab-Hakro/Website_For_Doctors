{"version":3,"sources":["../../src/query/core/apiState.ts","../../src/query/core/rtkImports.ts","../../src/query/utils/copyWithStructuralSharing.ts","../../src/query/utils/countObjectKeys.ts","../../src/query/utils/flatten.ts","../../src/query/utils/isAbsoluteUrl.ts","../../src/query/utils/isDocumentVisible.ts","../../src/query/utils/isNotNullish.ts","../../src/query/utils/isOnline.ts","../../src/query/utils/joinUrls.ts","../../src/query/utils/getOrInsert.ts","../../src/query/fetchBaseQuery.ts","../../src/query/HandledError.ts","../../src/query/retry.ts","../../src/query/core/setupListeners.ts","../../src/query/endpointDefinitions.ts","../../src/query/core/buildThunks.ts","../../src/query/core/buildInitiate.ts","../../src/tsHelpers.ts","../../src/query/core/buildSlice.ts","../../src/query/core/buildSelectors.ts","../../src/query/createApi.ts","../../src/query/defaultSerializeQueryArgs.ts","../../src/query/fakeBaseQuery.ts","../../src/query/core/module.ts","../../src/query/tsHelpers.ts","../../src/query/core/buildMiddleware/batchActions.ts","../../src/query/core/buildMiddleware/cacheCollection.ts","../../src/query/core/buildMiddleware/cacheLifecycle.ts","../../src/query/core/buildMiddleware/devMiddleware.ts","../../src/query/core/buildMiddleware/invalidationByTags.ts","../../src/query/core/buildMiddleware/polling.ts","../../src/query/core/buildMiddleware/queryLifecycle.ts","../../src/query/core/buildMiddleware/windowEventHandling.ts","../../src/query/core/buildMiddleware/index.ts","../../src/query/core/index.ts"],"sourcesContent":["import type { SerializedError } from '@reduxjs/toolkit';\nimport type { BaseQueryError } from '../baseQueryTypes';\nimport type { BaseEndpointDefinition, EndpointDefinitions, InfiniteQueryDefinition, MutationDefinition, PageParamFrom, QueryArgFromAnyQuery, QueryDefinition, ResultTypeFrom } from '../endpointDefinitions';\nimport type { Id, WithRequiredProp } from '../tsHelpers';\nexport type QueryCacheKey = string & {\n  _type: 'queryCacheKey';\n};\nexport type QuerySubstateIdentifier = {\n  queryCacheKey: QueryCacheKey;\n};\nexport type MutationSubstateIdentifier = {\n  requestId: string;\n  fixedCacheKey?: string;\n} | {\n  requestId?: string;\n  fixedCacheKey: string;\n};\nexport type RefetchConfigOptions = {\n  refetchOnMountOrArgChange: boolean | number;\n  refetchOnReconnect: boolean;\n  refetchOnFocus: boolean;\n};\nexport type PageParamFunction<DataType, PageParam> = (firstPage: DataType, allPages: Array<DataType>, firstPageParam: PageParam, allPageParams: Array<PageParam>) => PageParam | undefined | null;\nexport type InfiniteQueryConfigOptions<DataType, PageParam> = {\n  /**\n   * The initial page parameter to use for the first page fetch.\n   */\n  initialPageParam: PageParam;\n  /**\n   * This function is required to automatically get the next cursor for infinite queries.\n   * The result will also be used to determine the value of `hasNextPage`.\n   */\n  getNextPageParam: PageParamFunction<DataType, PageParam>;\n  /**\n   * This function can be set to automatically get the previous cursor for infinite queries.\n   * The result will also be used to determine the value of `hasPreviousPage`.\n   */\n  getPreviousPageParam?: PageParamFunction<DataType, PageParam>;\n  /**\n   * If specified, only keep this many pages in cache at once.\n   * If additional pages are fetched, older pages in the other\n   * direction will be dropped from the cache.\n   */\n  maxPages?: number;\n};\nexport type InfiniteData<DataType, PageParam> = {\n  pages: Array<DataType>;\n  pageParams: Array<PageParam>;\n};\n\n/**\n * Strings describing the query state at any given time.\n */\nexport enum QueryStatus {\n  uninitialized = 'uninitialized',\n  pending = 'pending',\n  fulfilled = 'fulfilled',\n  rejected = 'rejected',\n}\nexport type RequestStatusFlags = {\n  status: QueryStatus.uninitialized;\n  isUninitialized: true;\n  isLoading: false;\n  isSuccess: false;\n  isError: false;\n} | {\n  status: QueryStatus.pending;\n  isUninitialized: false;\n  isLoading: true;\n  isSuccess: false;\n  isError: false;\n} | {\n  status: QueryStatus.fulfilled;\n  isUninitialized: false;\n  isLoading: false;\n  isSuccess: true;\n  isError: false;\n} | {\n  status: QueryStatus.rejected;\n  isUninitialized: false;\n  isLoading: false;\n  isSuccess: false;\n  isError: true;\n};\nexport function getRequestStatusFlags(status: QueryStatus): RequestStatusFlags {\n  return {\n    status,\n    isUninitialized: status === QueryStatus.uninitialized,\n    isLoading: status === QueryStatus.pending,\n    isSuccess: status === QueryStatus.fulfilled,\n    isError: status === QueryStatus.rejected\n  } as any;\n}\n\n/**\n * @public\n */\nexport type SubscriptionOptions = {\n  /**\n   * How frequently to automatically re-fetch data 